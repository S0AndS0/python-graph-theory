---
layout: post
title:  "Agents 00"
date:   2019-04-07 06:04:58 -0700
categories: graph
---
{%- include mathjax.html -%}


> If this is your first time here it might be a good idea to start at the [`Points`][points] series, and it also might be helpful (though not required) to review the how the [`Hybrid_Iterator`][priority-buffer] `class` was used within the priority buffer series, because the following `Agent` `class` will also be inheriting from `Hybrid_Iterator`

___


What I'll be asking of an `Agent` any time `next()` or `__next__()` is called, is to look at it's current `Point`'s `neighbors`, consider those that the `Agent` has not visited and set the one of those to `self['heading']`, then return it`self` for further consideration. When the `Agent` no longer has anywhere left to travel (without backtracking), they'll throw/`raise` the specified error object to signal to the calling process that the they're finished.


> As a refresher here's a _sketch_ of `Hybrid_Iterator`'s `super` relationships with `dict` and `Iterator` `class`es, and a link to [`hybrid_iterator/__init__.py`](https://github.com/S0AndS0/python-graph-theory/blob/647903d1412df513f4f030b963e4b25d0ec3255e/python_examples/hybrid_iterator/__init__.py)


$$
\color{#CD8C00}{\fbox{ dict }{
  \color{#2E8B57}{\xleftarrow[]{
    \color{#000}{\text{super}_{\left(key\_word\_args\right)}}
  }}
  \over{\color{#CD8C00}{
    \xrightarrow[\color{#000}{\text{returned value}}]{}
  }}
}}
\color{#2E8B57}{\fbox{ Hybrid~Iterator }{
  \color{#2E8B57}{\xrightarrow[]{
    \color{#000}{\text{super}_{\left(key\_word\_args\right)}}
  }}
  \over{\color{#00A}{
    \xleftarrow[\color{#000}{\text{returned value}}]{}
  }}
}}
\color{#00A}{\fbox{ Iterator }}
$$

> And a _sketch_ of what the following code hopes to build

$$
\color{#2E8B57}{\fbox{ Hybrid~Iterator }{
  \color{#8C0073}{\xleftarrow[]{
    \color{#000}{\text{super}_{\left(key\_word\_args\right)}}
  }}
  \over{\color{#2E8B57}{
    \xrightarrow[\color{#000}{\text{returned value}}]{}
  }}
}}
\color{#8C0073}{\fbox{ Agent }}
$$



```python
#!/usr/bin/env python
from __future__ import absolute_import

import sys
sys.dont_write_bytecode = True

from random import randint

from hybrid_iterator import Hybrid_Iterator


class Agent(Hybrid_Iterator):
    """
    Let `point` be a `Point` instance of where this `Agent` is currently
    """

    def __init__(self, name, point, **kwargs):
        super(Agent, self).__init__(**kwargs)
        self.update(
            name = name,
            point = point,
            visited = [],
            heading = {})

    def set_heading(self, routes = None):
        """
        Sets `self['heading']` from unvisited `routes`
        If multiple choices are available a random one is picked.
        """
        if not routes:
            routs = self['point']['neighbors']

        self['heading'] = {}
        courses = {}
        visited_addresses = [x.keys()[0] for x in self['visited']]
        for address, cost in routes.items():
            if address not in visited_addresses:
                courses.update({address: cost})

        target_key = 0
        if len(courses.keys()) > 1:
            # ... choose a random heading if
            #     multiple courses are available
            target_key = randint(0, int(len(courses.keys()) - 1))

        if courses:
            address = courses.keys()[target_key]
            self['heading'] = {address: courses.pop(address)}

        return self['heading']

    def next(self):
        """
        Calls `self.set_heading()`, `raises` a `GeneratorExit`
        when there is no where left to go.
        """
        self.set_heading(routes = self['point']['neighbors'])

        if not self['heading']:
            self.throw(GeneratorExit)

        return self


if __name__ == '__main__':
    raise Exception("This file must be used as a module!")
```


> By separating out the behavior of an `Agent` from the `next` calls, sub-classing custom a new agent with a different `set_heading` method _should_ be relatively easy, and not require too much editing of code further up the stack.
>
> Hint, by sub-classing and borrowing the `cheapest` of `routs` method from the `Point` class it's possible to make a _`Frugal_Agent`_, here's a really quick example of what that could look like...


```python
from graph.agents import Agent


class Frugal_Agent(Agent):
    def next(self):
        neighbors = self['point']['neighbors']
        cheapest = self['point'].cheapest(neighbors)
        self.set_heading(cheapest)

        if not self['heading']:
            self.throw(GeneratorExit)

        return self
```


In order to test more easily this new `class` that makes use of `Hybrid_Iterator` from a parent directory, a temporary script file should be written under the _root_ directory for the Python project, eg. `python_examples/bills_adventure.py`. This test file could begin a bit like...


```python
#!/usr/bin/env python

import sys
sys.dont_write_bytecode = True


from graph.points import Point
from graph.agents import Agent


X = 0.2
O = 0.7
points = {
    'u': Point(address = 'u', neighbors = {'v': X, 'w': X}),
    'v': Point(address = 'v', neighbors = {'u': O, 'w': X}),
    'w': Point(address = 'w', neighbors = {'u': O, 'v': X}),
}
```

Initializing a set of four `Agents` could then look like...


```python
agents = {
    'Bill': Agent(name = 'Bill', point = points['u']),
    'Alice': Agent(name = 'Alice', point = points['u']),
    'Tom': Agent(name = 'Tom', point = points['v']),
    'Jain': Agent(name = 'Jain', point = points['w']),
}
```


> Note, if ya wanted to update the `points` `population` with `name`s of `Agent`s that could look like...


```python
for agent in agents.values():
    agent['point']['population'].append(agent['name'])
```


> ... though that does then require updating a `Point`'s population every-time an `Agent` wants to move, that would be ontop of updating an `Agent`'s reference to a `Point` too. And definitely read the `Warning` latter on in this post about recursion limits.


... and letting `Bill` _wander about_, safely, could look like...


```python
count = 0
agent_key = 'Bill'

for step in agents[agent_key]:
    name = step['name']
    here = step['point']['address']
    there = step['heading'].keys()[0]
    cost = step['heading'][there]

    print("{name} paid {cost} to get from {here} to {there}".format(
        name = name,
        cost = cost,
        here = here,
        there = there))

    points[here]['population'].remove(name)
    points[there]['population'].append(name)
    step['visited'].append({there: cost})
    step['point'] = points[there]

    count += 1
    if count > 4:
        raise Exception("Hunt for bugs!")


print("Places that {0} has been -> {1}\n\tcurrently at -> at {2}".format(
    agents[agent_key]['name'],
    agents[agent_key]['visited'],
    agents[agent_key]['point']['address']))
```


> This _safety_ looping with `count` is a good habit to get into when testing a `class`s' iterative behavior; without it one of the many `for` loops _could_ loop indefinitely from some bug or uncaught _edge case_.
>
> If/when that happens, a loop that never ends, try _mashing_ `Ctrl^c` for a bit, or searching for the Process ID so that it can be terminated with _`kill -9 <PID>`_.


... output may look something like...


```
Bill paid 0.2 to get from u to v
Bill paid 0.2 to get from v to w
Places that Bill has been -> [{'v': 0.2}, {'w': 0.2}]
    currently at -> w
```


Next up is addressing how to move more than one agent at a time, when you're ready feel free to start in on the [graph series][graph].


{% capture points_series %}{%- post_url 2019-04-02-points-00-preface -%}{% endcapture %}
[points]: {{ points_series | relative_url }}

{% capture priority_buffer_series %}{%- post_url 2019-04-03-priority-buffer-00 -%}{% endcapture %}
[priority-buffer]: {{ priority_buffer_series | relative_url }}

{% capture graph_series %}{%- post_url 2019-04-02-points-00-preface -%}{% endcapture %}
[graphs]: {{ graph_series | relative_url }}
